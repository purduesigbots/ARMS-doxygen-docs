.TH "C:/Users/btdav/Documents/COURSES/SIGBOTS/SOFTWARE/ARMS/include/ARMS/config.h" 3 "Sun Oct 16 2022" "ARMS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
C:/Users/btdav/Documents/COURSES/SIGBOTS/SOFTWARE/ARMS/include/ARMS/config.h \- The ARMS configuration file\&. This file is where you setup everything about your chassis, including the motors, the sensors, and constants\&. This is also where you will setup autonomous selector\&.  

.SH SYNOPSIS
.br
.PP
.SS "Namespaces"

.in +1c
.ti -1c
.RI "namespace \fBarms\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBODOM_DEBUG\fP   0"
.br
.RI "Odom debug mode\&. "
.ti -1c
.RI "#define \fBLEFT_MOTORS\fP   0"
.br
.RI "Left chassis motors\&. "
.ti -1c
.RI "#define \fBRIGHT_MOTORS\fP   0"
.br
.RI "Right chassis motors\&. "
.ti -1c
.RI "#define \fBGEARSET\fP   pros::E_MOTOR_GEAR_200"
.br
.RI "Chassis gearset\&. "
.ti -1c
.RI "#define \fBTPI\fP   0"
.br
.RI "Ticks per Inch\&. "
.ti -1c
.RI "#define \fBMIDDLE_TPI\fP   0"
.br
.RI "Middle Ticks Per Inch\&. "
.ti -1c
.RI "#define \fBTRACK_WIDTH\fP   0"
.br
.RI "Track Width\&. "
.ti -1c
.RI "#define \fBMIDDLE_DISTANCE\fP   0"
.br
.RI "Middle Distance\&. "
.ti -1c
.RI "#define \fBIMU_PORT\fP   0"
.br
.RI "IMU Port\&. "
.ti -1c
.RI "#define \fBENCODER_PORTS\fP   0, 0, 0"
.br
.RI "Encoder Ports\&. "
.ti -1c
.RI "#define \fBEXPANDER_PORT\fP   0"
.br
.RI "Encoder ADI Expander Port\&. "
.ti -1c
.RI "#define \fBENCODER_TYPE\fP   \fBarms::odom::ENCODER_ADI\fP"
.br
.RI "Encoder Type\&. "
.ti -1c
.RI "#define \fBSLEW_STEP\fP   0"
.br
.RI "Slew Step\&. "
.ti -1c
.RI "#define \fBLINEAR_EXIT_ERROR\fP   0"
.br
.RI "Linear Exit Error\&. "
.ti -1c
.RI "#define \fBANGULAR_EXIT_ERROR\fP   0"
.br
.RI "Angular Exit Error\&. "
.ti -1c
.RI "#define \fBSETTLE_THRESH_LINEAR\fP   0"
.br
.RI "Linear Settle Threshold\&. "
.ti -1c
.RI "#define \fBSETTLE_THRESH_ANGULAR\fP   0"
.br
.RI "Angular settle threshold\&. "
.ti -1c
.RI "#define \fBSETTLE_TIME\fP   0"
.br
.RI "Settle Time\&. "
.ti -1c
.RI "#define \fBLINEAR_KP\fP   0"
.br
.RI "Linear kP\&. "
.ti -1c
.RI "#define \fBLINEAR_KI\fP   0"
.br
.RI "Linear kI\&. "
.ti -1c
.RI "#define \fBLINEAR_KD\fP   0"
.br
.RI "Linear kD\&. "
.ti -1c
.RI "#define \fBTRACKING_KP\fP   0"
.br
.RI "Tracking kP\&. "
.ti -1c
.RI "#define \fBANGULAR_KP\fP   0"
.br
.RI "Angular kP\&. "
.ti -1c
.RI "#define \fBANGULAR_KI\fP   0"
.br
.RI "Angular kI\&. "
.ti -1c
.RI "#define \fBANGULAR_KD\fP   0"
.br
.RI "Angular kD\&. "
.ti -1c
.RI "#define \fBLEAD_PCT\fP   0"
.br
.RI "Lead Percent\&. "
.ti -1c
.RI "#define \fBMIN_ERROR\fP   0"
.br
.RI "Minimum Error\&. "
.ti -1c
.RI "#define \fBAUTONS\fP   0"
.br
.RI "Auton Selector Routines\&. "
.ti -1c
.RI "#define \fBHUE\fP   0"
.br
.RI "Autonomous Selctor Hue\&. "
.ti -1c
.RI "#define \fBDEFAULT\fP   0"
.br
.RI "Autonomous Selctor Default Routine\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBarms::init\fP ()"
.br
.RI "Initialize ARMS using the user defined constants \fBExample 1:\fP "
.in -1c
.SH "Detailed Description"
.PP 
The ARMS configuration file\&. This file is where you setup everything about your chassis, including the motors, the sensors, and constants\&. This is also where you will setup autonomous selector\&. 

YOU NEED TO REPLACE ALL OF THESE VALUES WITH THE CORRECT VALUES FOR YOUR ROBOT\&. 
.SH "Macro Definition Documentation"
.PP 
.SS "#define ODOM_DEBUG   0"

.PP
Odom debug mode\&. 
.PP
\fBParameters\fP
.RS 4
\fIdb\fP Enable/disable odom debug
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//enable odom debug messages
#define ODOM_DEBUG 1

.fi
.PP
 \fBExample 2:\fP 
.PP
.nf
//disable odom debug messages
#define ODOM_DEBUG 0

.fi
.PP
.PP
Enable/disable odometry debugging messages being sent to the terminal\&. This can be useful when trying to troubleshoot chassis movements\&. 
.SS "#define LEFT_MOTORS   0"

.PP
Left chassis motors\&. 
.PP
\fBParameters\fP
.RS 4
\fIports\fP the motor ports on the right side of the chassis
.RE
.PP
\fB Example 1: \fP 
.PP
.nf
// two motors on the left side of the chassis in ports 4 and 5
#define LEFT_MOTORS 4, 5

.fi
.PP
.PP
\fB Example 2: \fP 
.PP
.nf
// three motors on the left side of the chassis in ports 4, 5, and 6\&. The motor in port 5 is reversed
#define LEFT_MOTORS 4, -5, 6

.fi
.PP
.PP
Comma seperated ports that the chassis's left motors are in\&. Negative values reverse the motor on that port\&. 
.SS "#define RIGHT_MOTORS   0"

.PP
Right chassis motors\&. 
.PP
\fBParameters\fP
.RS 4
\fIports\fP the motor ports on the right side of the chassis
.RE
.PP
\fB Example 1: \fP 
.PP
.nf
// two motors on the right side of the chassis in ports 1 and 2
#define RIGHT_MOTORS 1, 2

.fi
.PP
.PP
\fB Example 2: \fP 
.PP
.nf
// three motors on the right side of the chassis in ports 1, 2, and 3\&. The motor in port 2 is reversed
#define RIGHT_MOTORS 1, -2, 3

.fi
.PP
.PP
Comma seperated ports that the chassis's right motors are in\&. Negative values reverse the motor on that port\&. 
.SS "#define GEARSET   pros::E_MOTOR_GEAR_200"

.PP
Chassis gearset\&. 
.PP
\fBParameters\fP
.RS 4
\fIrpm\fP the rpm of the chassis's motors
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using 200 rpm cartridges
#define GEARSET pros::E_MOTOR_GEAR_200

.fi
.PP
.PP
Sets the robot's chassis gearset to \fIrpm\fP\&. 
.SS "#define TPI   0"

.PP
Ticks per Inch\&. 
.PP
\fBParameters\fP
.RS 4
\fItpi\fP the number of encoder ticks per inch of forward robot movement\&.
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a tpi of 10\&.
#define TPI 10

.fi
.PP
.PP
Sets the number of encoder ticks per inch of forward robot movement to \fItpi\fP\&. 
.SS "#define MIDDLE_TPI   0"

.PP
Middle Ticks Per Inch\&. 
.PP
\fBParameters\fP
.RS 4
\fImtpi\fP encoder ticks per inch of robot movement for the perpendicular middle wheel
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a middle tpi of 10\&.
#define MIDDLE_TPI

.fi
.PP
.PP
Sets the number of middle encoder ticks per inch of perpendicular robot movement to \fItpi\fP\&. 
.SS "#define TRACK_WIDTH   0"

.PP
Track Width\&. 
.PP
\fBParameters\fP
.RS 4
\fItwidth\fP The track width of the robot (distance between left and right weels)
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a track width of 16 inches\&.
#define TRACK_WIDTH 16

.fi
.PP
.PP
Sets the number of encoder ticks per inch of forward robot movement to \fItpi\fP\&. 
.SS "#define MIDDLE_DISTANCE   0"

.PP
Middle Distance\&. 
.PP
\fBParameters\fP
.RS 4
\fIdist\fP the distance between the middle wheel and the center of the robot
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a middle distance of 2 inches\&.
#define MIDDLE_DISTANCE 2

.fi
.PP
 
.SS "#define IMU_PORT   0"

.PP
IMU Port\&. 
.PP
\fBParameters\fP
.RS 4
\fIport\fP the port the imu is plugged into\&. Set to 0 for disabled
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using an IMU in port 8
#define IMU_PORT 8

.fi
.PP
 \fBExample 2:\fP 
.PP
.nf
//don't use an IMU 
#define IMU_PORT 0

.fi
.PP
.PP
Sets the chassis' imu to the sensor in port \fIport\fP\&. 
.SS "#define ENCODER_PORTS   0, 0, 0"

.PP
Encoder Ports\&. 
.PP
\fBParameters\fP
.RS 4
\fIleft\fP the port the left encoder is plugged into\&. 0 for disabled\&.
.br
\fIright\fP the port the right encoder is plugged into\&. 0 for disabled\&.
.br
\fImiddle\fP the port the middle encoder is plugged into\&. 0 for disabled\&.
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using one parrallel encoder\&. IMU for heading and not worried about sidways movement
#define ENCODER_PORTS 1, 0, 0

.fi
.PP
 \fBExample 2:\fP 
.PP
.nf
//using all three encoders\&. No IMU for heading, so we will need to get our heading through encoders
#define ENCODER_PORTS 1, 3, 5

.fi
.PP
.PP
Sets up the 1-3 encoders being used on the bot\&. An \fBIMU_PORT\fP should be set if you do not use all 3 encoders\&. An encoder perpindicular to the chassis (middle) should be used if the robot is expected to be pushed sideways\&. Negative values reverse the direction of the encoder\&. A value of 0 disables the encoder and uses the integrated motor encoders instead\&. The values should be valid smart ports if using the V5 rotation sensor, or odd numbered adi ports if using the optical shaft encoders\&. This is configured at \fBENCODER_TYPE\fP If all encoders are disabled, the integrated encoders in the chassis motors will be used\&. 
.SS "#define EXPANDER_PORT   0"

.PP
Encoder ADI Expander Port\&. 
.PP
\fBParameters\fP
.RS 4
\fIport\fP the port the ADI expander is plugged into\&. 0 for disabled\&.
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using an ADI expander in port 1
#define EXPANDER_PORT 1

.fi
.PP
 \fBExample 2:\fP 
.PP
.nf
//don't use an ADI expander
#define EXPANDER_PORT 0

.fi
.PP
.PP
Uses the expander port in port \fIport\fP for the encoder's configured at \fBENCODER_PORTS\fP\&. 
.SS "#define ENCODER_TYPE   \fBarms::odom::ENCODER_ADI\fP"

.PP
Encoder Type\&. 
.PP
\fBParameters\fP
.RS 4
\fItype\fP The type of encoder being used
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using the new V5 Rotation sensors
#define ENCODER_TYPE arms::odom::ENCODER_ROTATION

.fi
.PP
.PP
\fBExample 2:\fP 
.PP
.nf
//using the old Optical Shaft Encoders
#define ENCODER_TYPE arms::odom::ENCODER_ADI

.fi
.PP
.PP
Which type of vex encoder is being used on the chassis\&. Using a mixture of encoder types is not currently supported\&. This influences what the valid values for \fBENCODER_PORTS\fP are\&. 
.SS "#define SLEW_STEP   0"

.PP
Slew Step\&. 
.PP
\fBParameters\fP
.RS 4
\fIstep\fP how much to slew the motors by each time the motors are updated
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a slew step of 10
#define SLEW_STEP 10

.fi
.PP
.PP
Sets the slew step to \fIstep\fP\&. A smaller value results more slew\&. 
.SS "#define LINEAR_EXIT_ERROR   0"

.PP
Linear Exit Error\&. 
.PP
\fBParameters\fP
.RS 4
\fIerror\fP the error to use when exiting linear movement
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using an error of 4 units
#define LINEAR_EXIT_ERROR 4

.fi
.PP
.PP
Sets the error to use when exiting linear movement to \fIerror\fP\&. 
.SS "#define ANGULAR_EXIT_ERROR   0"

.PP
Angular Exit Error\&. 
.PP
\fBParameters\fP
.RS 4
\fIerror\fP the error to use when exiting angular movement
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using an error of 4 units
#define ANGULAR_EXIT_ERROR 4

.fi
.PP
.PP
Sets the error to use when exiting angular movement to \fIerror\fP\&. 
.SS "#define SETTLE_THRESH_LINEAR   0"

.PP
Linear Settle Threshold\&. 
.PP
\fBParameters\fP
.RS 4
\fIthreshold\fP the threshold to use when settling linear movement
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a threshold of 1 units
#define SETTLE_THRESH_LINEAR 1

.fi
.PP
.PP
Sets the threshold to use when settling linear movement to \fIthreshold\fP\&. The robot is considered settled if it does not move this many units within the duration of \fBSETTLE_TIME\fP\&. 
.SS "#define SETTLE_THRESH_ANGULAR   0"

.PP
Angular settle threshold\&. 
.PP
\fBParameters\fP
.RS 4
\fIthreshold\fP the threshold to use when settling angular movement
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a threshold of 1 units
#define SETTLE_THRESH_ANGULAR 1

.fi
.PP
.PP
Sets the threshold to use when settling angular movement to \fIthreshold\fP\&. The robot is considered settled if it does not move this many units within the duration of \fBSETTLE_TIME\fP\&. 
.SS "#define SETTLE_TIME   0"

.PP
Settle Time\&. 
.PP
\fBParameters\fP
.RS 4
\fItime\fP the time the chassis must be still to be considered settled
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a settle time of 150 milliseconds
#define SETTLE_TIME 150

.fi
.PP
.PP
Sets the time the chassis must be still to be considered settled to \fItime\fP in milliseconds\&. A high settle time may make movements take too long to complete, where as a low settle time may cause the robot to exit its movement prematurely\&. 
.SS "#define LINEAR_KP   0"

.PP
Linear kP\&. 
.PP
\fBParameters\fP
.RS 4
\fIkp\fP the proportional constant for the linear motion PID controller
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a kP of 0\&.5
#define LINEAR_KP 0\&.5

.fi
.PP
.PP
Sets the proportional constant for the linear motion PID controller to \fIkp\fP\&. 
.SS "#define LINEAR_KI   0"

.PP
Linear kI\&. 
.PP
\fBParameters\fP
.RS 4
\fIki\fP the integral constant for the linear motion PID controller
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a ki of 0\&.5
#define LINEAR_KI 0\&.5

.fi
.PP
.PP
Sets the integral constant for the linear motion PID controller to \fIki\fP\&. 
.SS "#define LINEAR_KD   0"

.PP
Linear kD\&. 
.PP
\fBParameters\fP
.RS 4
\fIkd\fP the derivative constant for the linear motion PID controller
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a kd of 0\&.5
#define LINEAR_KD 0\&.5

.fi
.PP
.PP
Sets the derivative constant for the linear motion PID controller to \fIkd\fP\&. 
.SS "#define TRACKING_KP   0"

.PP
Tracking kP\&. 
.PP
\fBParameters\fP
.RS 4
\fItrackkp\fP the proportional constant for turning strength during point to point movements
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a Tracking kP of 60
#define TRACKING_KP 60

.fi
.PP
.PP
sets the proportional constant for turning strength during point to point movements to \fItrackkp\fP 
.SS "#define ANGULAR_KP   0"

.PP
Angular kP\&. 
.PP
\fBParameters\fP
.RS 4
\fIkp\fP the proportional constant for the angular motion PID controller
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a kP of 0\&.5
#define ANGULAR_KP 0\&.5

.fi
.PP
.PP
Sets the proportional constant for the angular motion PID controller to \fIkp\fP\&. 
.SS "#define ANGULAR_KI   0"

.PP
Angular kI\&. 
.PP
\fBParameters\fP
.RS 4
\fIki\fP the integral constant for the angular motion PID controller
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a ki of 0\&.5
#define ANGULAR_KI 0\&.5

.fi
.PP
.PP
Sets the integral constant for the angular motion PID controller to \fIki\fP\&. 
.SS "#define ANGULAR_KD   0"

.PP
Angular kD\&. 
.PP
\fBParameters\fP
.RS 4
\fIkd\fP the derivative constant for the angular motion PID controller
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a kd of 0\&.5
#define ANGULAR_KD 0\&.5

.fi
.PP
.PP
Sets the derivative constant for the angular motion PID controller to \fIkd\fP\&. 
.SS "#define LEAD_PCT   0"

.PP
Lead Percent\&. 
.PP
\fBParameters\fP
.RS 4
\fIpct\fP the lead percent to use for go to pose movements (boomerang controller)
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a pct of 0\&.3
#define LEAD_PCT 0\&.3

.fi
.PP
.PP
Sets the lead percent to use for go to pose movements to \fIpct\fP\&. In theory, lower percents will be more linear movements, while higher percents will be more curvy\&. 
.SS "#define MIN_ERROR   0"

.PP
Minimum Error\&. 
.PP
\fBParameters\fP
.RS 4
\fIerror\fP the minimum error for the robot to be considered at the target position
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a minimum error of 2
#define MIN_ERROR 2

.fi
.PP
.PP
Sets the minimum error for the robot to be considered at the target position to \fIerror\fP\&. 
.SS "#define AUTONS   0"

.PP
Auton Selector Routines\&. 
.PP
\fBParameters\fP
.RS 4
\fIauton_names\fP the names of your autonomous routines\&.
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using the autons "left", "middle", "right", and "nothing"
#define AUTONS "left", "middle", "right", "nothing"

.fi
.PP
.PP
Sets the auton names to run\&. The names should be seprated by commas\&. The maximum number of autons is 10\&. This is part of the autonomous selector configuration\&. More details can be found at \fBselector\&.h\fP 
.SS "#define HUE   0"

.PP
Autonomous Selctor Hue\&. 
.PP
\fBParameters\fP
.RS 4
\fIhue\fP the hue of your autonomous selector \fBExample 1:\fP 
.PP
.nf
//using a hue of 60 (yellow)
#define HUE 0

.fi
.PP
.RE
.PP
S This is part of the autonomous selector configuration\&. More details can be found at \fBselector\&.h\fP 
.SS "#define DEFAULT   0"

.PP
Autonomous Selctor Default Routine\&. 
.PP
\fBParameters\fP
.RS 4
\fIindex\fP the index for the default autonomous routine to run\&.
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using the default auton to be "left"
#define DEFAULT_AUTON 1

.fi
.PP
.PP
Sets the default auton to run\&. This is part of the autonomous selector configuration\&. More details can be found at \fBselector\&.h\fP 
.SH "Author"
.PP 
Generated automatically by Doxygen for ARMS from the source code\&.
