.TH "C:/Users/btdav/Documents/COURSES/SIGBOTS/SOFTWARE/ARMS/include/ARMS/config.h" 3 "Thu Jul 28 2022" "ARMS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
C:/Users/btdav/Documents/COURSES/SIGBOTS/SOFTWARE/ARMS/include/ARMS/config.h \- \fBThe ARMS configuration file\&. This file is where you setup everything about your chassis, including the motors, the sensors, and constants\&. This is also where you will setup autonomous selector\&.\fP  

.SH SYNOPSIS
.br
.PP
.SS "Namespaces"

.in +1c
.ti -1c
.RI "namespace \fBarms\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBODOM_DEBUG\fP   db"
.br
.RI "Odom debug mode\&. "
.ti -1c
.RI "#define \fBLEFT_MOTORS\fP   ports"
.br
.RI "Left chassis motors\&. "
.ti -1c
.RI "#define \fBRIGHT_MOTORS\fP   ports"
.br
.RI "Right chassis motors\&. "
.ti -1c
.RI "#define \fBGEARSET\fP   rpm"
.br
.RI "Chassis gearset\&. "
.ti -1c
.RI "#define \fBDISTANCE_CONSTANT\fP   dist"
.br
.RI "Distance Constant\&. "
.ti -1c
.RI "#define \fBDEGREE_CONSTANT\fP   deg"
.br
.RI "Degree Constant\&. "
.ti -1c
.RI "#define \fBIMU_PORT\fP   port"
.br
.RI "IMU Port\&. "
.ti -1c
.RI "#define \fBENCODER_PORTS\fP   left, middle, right"
.br
.RI "Encoder Ports\&. "
.ti -1c
.RI "#define \fBEXPANDER_PORT\fP   port"
.br
.RI "Encoder ADI Expander Port\&. "
.ti -1c
.RI "#define \fBENCODER_TYPE\fP   type"
.br
.RI "Encoder Type\&. "
.ti -1c
.RI "#define \fBLEFT_RIGHT_DISTANCE\fP   dist"
.br
.RI "Left Right Distance\&. "
.ti -1c
.RI "#define \fBMIDDLE_DISTANCE\fP   dist"
.br
.RI "Middle Distance\&. "
.ti -1c
.RI "#define \fBMIDDLE_TPI\fP   tpi"
.br
.RI "Middle TPI\&. "
.ti -1c
.RI "#define \fBSLEW_STEP\fP   step"
.br
.RI "Slew Step\&. "
.ti -1c
.RI "#define \fBLINEAR_EXIT_ERROR\fP   error"
.br
.RI "Linear Exit Error\&. "
.ti -1c
.RI "#define \fBANGULAR_EXIT_ERROR\fP   error"
.br
.RI "Angular Exit Error\&. "
.ti -1c
.RI "#define \fBSETTLE_THRESH_LINEAR\fP   \&.5"
.br
.RI "Linear Settle Threshold\&. "
.ti -1c
.RI "#define \fBSETTLE_THRESH_ANGULAR\fP   1"
.br
.RI "Angular settle threshold\&. "
.ti -1c
.RI "#define \fBSETTLE_TIME\fP   time"
.br
.RI "Settle Time\&. "
.ti -1c
.RI "#define \fBLINEAR_KP\fP   kp"
.br
.RI "Linear kP\&. "
.ti -1c
.RI "#define \fBLINEAR_KI\fP   ki"
.br
.RI "Linear kI\&. "
.ti -1c
.RI "#define \fBLINEAR_KD\fP   kd"
.br
.RI "Linear kD\&. "
.ti -1c
.RI "#define \fBTRACKING_KP\fP   60"
.br
.ti -1c
.RI "#define \fBANGULAR_KP\fP   kp"
.br
.RI "Angular kP\&. "
.ti -1c
.RI "#define \fBANGULAR_KI\fP   ki"
.br
.RI "Angular kI\&. "
.ti -1c
.RI "#define \fBANGULAR_KD\fP   kd"
.br
.RI "Angular kD\&. "
.ti -1c
.RI "#define \fBMIN_ERROR\fP   error"
.br
.RI "Minimum Error\&. "
.ti -1c
.RI "#define \fBAUTONS\fP   auton_names"
.br
.RI "Auton Selector Routines\&. "
.ti -1c
.RI "#define \fBHUE\fP   hue"
.br
.RI "Autonomous Selctor Hue\&. "
.ti -1c
.RI "#define \fBDEFAULT\fP   index"
.br
.RI "Autonomous Selctor Default Routine\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBarms::init\fP ()"
.br
.RI "Initialize ARMS using the user defined constants \fBExample 1:\fP "
.in -1c
.SH "Detailed Description"
.PP 
\fBThe ARMS configuration file\&. This file is where you setup everything about your chassis, including the motors, the sensors, and constants\&. This is also where you will setup autonomous selector\&.\fP 


.SH "Macro Definition Documentation"
.PP 
.SS "#define ODOM_DEBUG   db"

.PP
Odom debug mode\&. 
.PP
\fBParameters\fP
.RS 4
\fIdb\fP Enable/disable odom debug
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//enable odom debug messages
#define ODOM_DEBUG 1

.fi
.PP
 \fBExample 2:\fP 
.PP
.nf
//disable odom debug messages
#define ODOM_DEBUG 0

.fi
.PP
.PP
Enable/disable odometry debugging messages being sent to the terminal\&. This can be useful when trying to troubleshoot chassis movements\&. 
.SS "#define LEFT_MOTORS   ports"

.PP
Left chassis motors\&. 
.PP
\fBParameters\fP
.RS 4
\fIports\fP the motor ports on the right side of the chassis
.RE
.PP
\fB Example 1: \fP 
.PP
.nf
// two motors on the left side of the chassis in ports 4 and 5
#define LEFT_MOTORS 4, 5

.fi
.PP
.PP
\fB Example 2: \fP 
.PP
.nf
// three motors on the left side of the chassis in ports 4, 5, and 6\&. the motor in port 5 is reversed
#define LEFT_MOTORS 4, -5, 6

.fi
.PP
.PP
Comma seperated ports that the chassis's left motors are in\&. Negative values reverse the motor on that port\&. 
.SS "#define RIGHT_MOTORS   ports"

.PP
Right chassis motors\&. 
.PP
\fBParameters\fP
.RS 4
\fIports\fP the motor ports on the right side of the chassis
.RE
.PP
\fB Example 1: \fP 
.PP
.nf
// two motors on the right side of the chassis in ports 1 and 2
#define RIGHT_MOTORS 1, 2

.fi
.PP
.PP
\fB Example 2: \fP 
.PP
.nf
// three motors on the right side of the chassis in ports 1, 2, and 3\&. the motor in port 2 is reversed
#define RIGHT_MOTORS 1, -2, 3

.fi
.PP
.PP
Comma seperated ports that the chassis's right motors are in\&. Negative values reverse the motor on that port\&. 
.SS "#define GEARSET   rpm"

.PP
Chassis gearset\&. 
.PP
\fBParameters\fP
.RS 4
\fIrpm\fP the rpm of the chassis's motors
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using 200 rpm cartridges
#define GEARSET 200

.fi
.PP
.PP
Sets the robot's chassis gearset to \fIrpm\fP\&. 
.SS "#define DISTANCE_CONSTANT   dist"

.PP
Distance Constant\&. 
.PP
\fBParameters\fP
.RS 4
\fIdist\fP the robot's distance constant
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//use 60 encoder ticks per unit
#define DISTANCE_CONSTANT 60

.fi
.PP
.PP
Sets the robot's distance constant to \fIdist\fP\&. 
.SS "#define DEGREE_CONSTANT   deg"

.PP
Degree Constant\&. 
.PP
\fBParameters\fP
.RS 4
\fIdeg\fP the robot's degree constant
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using an IMU for robot's heading
#define DEGREE_CONSTANT 1

.fi
.PP
 \fBExample 2:\fP 
.PP
.nf
//use 15 encoder ticks per degree
#define DEGREE_CONSTANT 15

.fi
.PP
.PP
Sets the robot's degree constant to \fIdeg\fP\&. 
.SS "#define IMU_PORT   port"

.PP
IMU Port\&. 
.PP
\fBParameters\fP
.RS 4
\fIport\fP the port the imu is plugged into\&. Set to 0 for disabled
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using an IMU in port 8
#define IMU_PORT 8

.fi
.PP
 \fBExample 2:\fP 
.PP
.nf
//don't use an IMU 
#define IMU_PORT 0

.fi
.PP
.PP
Sets the chassis' imu to the sensor in port \fIport\fP\&. 
.SS "#define ENCODER_PORTS   left, middle, right"

.PP
Encoder Ports\&. 
.PP
\fBParameters\fP
.RS 4
\fIleft\fP the port the left encoder is plugged into\&. 0 for disabled\&.
.br
\fImiddle\fP the port the middle encoder is plugged into\&. 0 for disabled\&.
.br
\fIright\fP the port the right encoder is plugged into\&. 0 for disabled\&.
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using one parrallel encoder\&. IMU for heading and not worried about sidways movement
#define ENCODER_PORTS 1, 0, 0

.fi
.PP
 \fBExample 2:\fP 
.PP
.nf
//using all three encoders\&. No IMU for heading, so we will need to get our heading through encoders
#define ENCODER_PORTS 1, 3, 5

.fi
.PP
.PP
Sets up the 1-3 encoders being used on the bot\&. At least 1 encoder parrallel to the chassis must be used for odometry to work\&. If either left or right encoder is set to 0, an IMU must also be used\&. An encoder perpindicular to the chassis (middle) should be used if the robot is expected to be pushed sideways\&. Negative values reverse the direction of the encoder\&. A value of 0 disables the encoder\&. The values should be valid smart ports if using the V5 rotation sensor, or odd numbered adi ports if using the optical shaft encoders\&. This is configured at \fBENCODER_TYPE\fP If all encoders are disabled, the integrated encoders in the chassis motors will be used\&. 
.SS "#define EXPANDER_PORT   port"

.PP
Encoder ADI Expander Port\&. 
.PP
\fBParameters\fP
.RS 4
\fIport\fP the port the ADI expander is plugged into\&. 0 for disabled\&.
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using an ADI expander in port 1
#define ADI_PORT 1

.fi
.PP
 \fBExample 2:\fP 
.PP
.nf
//don't use an ADI expander
#define ADI_PORT 0

.fi
.PP
.PP
Uses the expander port in port \fIport\fP for the encoder's configured at \fBENCODER_PORTS\fP\&. 
.SS "#define ENCODER_TYPE   type"

.PP
Encoder Type\&. 
.PP
\fBParameters\fP
.RS 4
\fItype\fP The type of encoder being used
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using the new V5 Rotation sensors
#define ENCODER_TYPE arms::odom::ENCODER_ROTATION

.fi
.PP
.PP
\fBExample 2:\fP 
.PP
.nf
//using the old Optical Shaft Encoders
#define ENCODER_TYPE arms::odom::ENCODER_ADI

.fi
.PP
.PP
Which type of vex encoder is being used on the chassis\&. Using a mixture of encoder types is not currently supported\&. This influences what the valid values for \fBENCODER_PORTS\fP are\&. 
.SS "#define LEFT_RIGHT_DISTANCE   dist"

.PP
Left Right Distance\&. 
.PP
\fBParameters\fP
.RS 4
\fIdist\fP the distance between the left and right tracking wheels
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a distance of 10 inches between the left and right tracking wheels
#define LEFT_RIGHT_DISTANCE 10

.fi
.PP
.PP
Sets the distance between the left and right tracking wheels to \fIdist\fP\&. Should be set to 0 if only using 1 tracker wheel 
.SS "#define MIDDLE_DISTANCE   dist"

.PP
Middle Distance\&. 
.PP
\fBParameters\fP
.RS 4
\fIdist\fP the distance between the middle tracking wheel and the turning center of the chassis
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a distance of 7 inches between the middle tracking wheel and the turning center of the chassis
#define MIDDLE_DISTANCE 7

.fi
.PP
.PP
Sets the distance between the middle tracking wheel and the turning center of the chassis to \fIdist\fP\&. Should be set to 0 if not using a middle tracker wheel\&. 
.SS "#define MIDDLE_TPI   tpi"

.PP
Middle TPI\&. 
.PP
\fBParameters\fP
.RS 4
\fItpi\fP the ticks per inch of the middle encoder wheel
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a TPI of 100
#define MIDDLE_TPI 100

.fi
.PP
.PP
Sets the TPI of the middle encoder wheel\&. 
.SS "#define SLEW_STEP   step"

.PP
Slew Step\&. 
.PP
\fBParameters\fP
.RS 4
\fIstep\fP how much to slew the motors by each time the motors are updated
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a slew step of 10
#define SLEW_STEP 10

.fi
.PP
.PP
Sets the slew step to \fIstep\fP\&. A smaller value results more slew\&. 
.SS "#define LINEAR_EXIT_ERROR   error"

.PP
Linear Exit Error\&. 
.PP
\fBParameters\fP
.RS 4
\fIerror\fP the error to use when exiting linear movement
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using an error of 4 units
#define LINEAR_EXIT_ERROR 4

.fi
.PP
.PP
Sets the error to use when exiting linear movement to \fIerror\fP\&. 
.SS "#define ANGULAR_EXIT_ERROR   error"

.PP
Angular Exit Error\&. 
.PP
\fBParameters\fP
.RS 4
\fIerror\fP the error to use when exiting angular movement
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using an error of 4 units
#define ANGULAR_EXIT_ERROR 4

.fi
.PP
.PP
Sets the error to use when exiting angular movement to \fIerror\fP\&. 
.SS "#define SETTLE_THRESH_LINEAR   \&.5"

.PP
Linear Settle Threshold\&. 
.PP
\fBParameters\fP
.RS 4
\fIthreshold\fP the threshold to use when settling linear movement
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a threshold of 1 units
#define LINEAR_SETTLE_THRESHOLD 1

.fi
.PP
.PP
Sets the threshold to use when settling linear movement to \fIthreshold\fP\&. The robot is considered settled if it does not move this many units within the duration of \fBSETTLE_TIME\fP\&. 
.SS "#define SETTLE_THRESH_ANGULAR   1"

.PP
Angular settle threshold\&. 
.PP
\fBParameters\fP
.RS 4
\fIthreshold\fP the threshold to use when settling angular movement
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a threshold of 1 units
#define ANGULAR_SETTLE_THRESHOLD 1

.fi
.PP
.PP
Sets the threshold to use when settling angular movement to \fIthreshold\fP\&. The robot is considered settled if it does not move this many units within the duration of \fBSETTLE_TIME\fP\&. 
.SS "#define SETTLE_TIME   time"

.PP
Settle Time\&. 
.PP
\fBParameters\fP
.RS 4
\fItime\fP the time the chassis must be still to be considered settled
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a settle time of 150 milliseconds
#define SETTLE_TIME 150

.fi
.PP
.PP
Sets the time the chassis must be still to be considered settled to \fItime\fP in milliseconds\&. A high settle time may make movements take too long to complete, where as a low settle time may cause the robot to exit its movement prematurely\&. 
.SS "#define LINEAR_KP   kp"

.PP
Linear kP\&. 
.PP
\fBParameters\fP
.RS 4
\fIkp\fP the proportional constant for the linear motion PID controller
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a kP of 0\&.5
#define LINEAR_KP 0\&.5

.fi
.PP
.PP
Sets the proportional constant for the linear motion PID controller to \fIkp\fP\&. 
.SS "#define LINEAR_KI   ki"

.PP
Linear kI\&. 
.PP
\fBParameters\fP
.RS 4
\fIki\fP the integral constant for the linear motion PID controller
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a ki of 0\&.5
#define LINEAR_KI 0\&.5

.fi
.PP
.PP
Sets the integral constant for the linear motion PID controller to \fIki\fP\&. 
.SS "#define LINEAR_KD   kd"

.PP
Linear kD\&. 
.PP
\fBParameters\fP
.RS 4
\fIkd\fP the derivative constant for the linear motion PID controller
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a kd of 0\&.5
#define LINEAR_KD 0\&.5

.fi
.PP
.PP
Sets the derivative constant for the linear motion PID controller to \fIkd\fP\&. 
.SS "#define TRACKING_KP   60"

.SS "#define ANGULAR_KP   kp"

.PP
Angular kP\&. 
.PP
\fBParameters\fP
.RS 4
\fIkp\fP the proportional constant for the angular motion PID controller
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a kP of 0\&.5
#define ANGULAR_KP 0\&.5

.fi
.PP
.PP
Sets the proportional constant for the angular motion PID controller to \fIkp\fP\&. 
.SS "#define ANGULAR_KI   ki"

.PP
Angular kI\&. 
.PP
\fBParameters\fP
.RS 4
\fIki\fP the integral constant for the angular motion PID controller
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a ki of 0\&.5
#define ANGULAR_KI 0\&.5

.fi
.PP
.PP
Sets the integral constant for the angular motion PID controller to \fIki\fP\&. 
.SS "#define ANGULAR_KD   kd"

.PP
Angular kD\&. 
.PP
\fBParameters\fP
.RS 4
\fIkd\fP the derivative constant for the angular motion PID controller
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a kd of 0\&.5
#define ANGULAR_KD 0\&.5

.fi
.PP
.PP
Sets the derivative constant for the angular motion PID controller to \fIkd\fP\&. 
.SS "#define MIN_ERROR   error"

.PP
Minimum Error\&. 
.PP
\fBParameters\fP
.RS 4
\fIerror\fP the minimum error for the robot to be considered at the target position
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using a minimum error of 2
#define MIN_ERROR 2

.fi
.PP
.PP
Sets the minimum error for the robot to be considered at the target position to \fIerror\fP\&. 
.SS "#define AUTONS   auton_names"

.PP
Auton Selector Routines\&. 
.PP
\fBParameters\fP
.RS 4
\fIauton_names\fP the names of your autonomous routines\&.
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using the autons "left", "middle", "right", and "nothing"
#define AUTON_NAMES "left", "middle", "right", "nothing", ""

.fi
.PP
.PP
Sets the auton names to run\&. The names should be seprated by commas\&. The maximum number of autons is 10\&. This is part of the autonomous selector configuration\&. More details can be found at \fBselector\&.h\fP 
.SS "#define HUE   hue"

.PP
Autonomous Selctor Hue\&. 
.PP
\fBParameters\fP
.RS 4
\fIhue\fP the names of your autonomous routines\&.
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using the autons "left", "middle", "right", and "nothing"
#define AUTON_NAMES "left", "middle", "right", "nothing", ""

.fi
.PP
.PP
Sets the auton names to run\&. The names should be seprated by commas\&. The maximum number of autons is 10\&. YOU MUST PUT AN EMPTY STRING AT THE END OF THE LIST\&. This is part of the autonomous selector configuration\&. More details can be found at \fBselector\&.h\fP 
.SS "#define DEFAULT   index"

.PP
Autonomous Selctor Default Routine\&. 
.PP
\fBParameters\fP
.RS 4
\fIindex\fP the index for the default autonomous routine to run\&.
.RE
.PP
\fBExample 1:\fP 
.PP
.nf
//using the default auton to be "left"
#define DEFAULT_AUTON 1

.fi
.PP
.PP
Sets the default auton to run\&. This is part of the autonomous selector configuration\&. More details can be found at \fBselector\&.h\fP 
.SH "Author"
.PP 
Generated automatically by Doxygen for ARMS from the source code\&.
